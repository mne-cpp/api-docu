<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MNE-CPP: DISP3DLIB::Interpolation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MNE-CPP_Doxygen_Logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MNE-CPP
   &#160;<span id="projectnumber">0.1.9</span>
   </div>
   <div id="projectbrief">A Framework for Electrophysiology</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>DISP3DLIB</b></li><li class="navelem"><a class="el" href="a02344.html">Interpolation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="a02341.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DISP3DLIB::Interpolation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class holds methods for creating distance-based weight matrices and for interpolating signals.  
 <a href="a02344.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00794_source.html">interpolation.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae78200c5ac018b82d0c2ddd5e0987f42"><td class="memItemLeft" align="right" valign="top">typedef QSharedPointer&lt; <a class="el" href="a02344.html">Interpolation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#ae78200c5ac018b82d0c2ddd5e0987f42">SPtr</a></td></tr>
<tr class="separator:ae78200c5ac018b82d0c2ddd5e0987f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065d5937d04e1d500da2e7366f7343e5"><td class="memItemLeft" align="right" valign="top">typedef QSharedPointer&lt; const <a class="el" href="a02344.html">Interpolation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#a065d5937d04e1d500da2e7366f7343e5">ConstSPtr</a></td></tr>
<tr class="separator:a065d5937d04e1d500da2e7366f7343e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3bca8308a44135286a0bf9479dbeee4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#ac3bca8308a44135286a0bf9479dbeee4">Interpolation</a> ()=delete</td></tr>
<tr class="separator:ac3bca8308a44135286a0bf9479dbeee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4311446f073b11ec8e644981a92aeef3"><td class="memItemLeft" align="right" valign="top">static QSharedPointer&lt; Eigen::SparseMatrix&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#a4311446f073b11ec8e644981a92aeef3">createInterpolationMat</a> (const QVector&lt; int &gt; &amp;vecProjectedSensors, const QSharedPointer&lt; Eigen::MatrixXd &gt; matDistanceTable, double(*interpolationFunction)(double), const double dCancelDist=FLOAT_INFINITY, const QVector&lt; int &gt; &amp;vecExcludeIndex=QVector&lt; int &gt;())</td></tr>
<tr class="separator:a4311446f073b11ec8e644981a92aeef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f29bfc9a18cfa3833486c6c4c487e8"><td class="memItemLeft" align="right" valign="top">static Eigen::VectorXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#a54f29bfc9a18cfa3833486c6c4c487e8">interpolateSignal</a> (const QSharedPointer&lt; Eigen::SparseMatrix&lt; float &gt; &gt; matInterpolationMatrix, const QSharedPointer&lt; Eigen::VectorXf &gt; &amp;vecMeasurementData)</td></tr>
<tr class="separator:a54f29bfc9a18cfa3833486c6c4c487e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3607f1bfdf7eeb7c3a11027abadf05ba"><td class="memItemLeft" align="right" valign="top">static Eigen::VectorXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#a3607f1bfdf7eeb7c3a11027abadf05ba">interpolateSignal</a> (const Eigen::SparseMatrix&lt; float &gt; &amp;matInterpolationMatrix, const Eigen::VectorXf &amp;vecMeasurementData)</td></tr>
<tr class="separator:a3607f1bfdf7eeb7c3a11027abadf05ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96074fbf11669ccd753c22b172aa1cd2"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#a96074fbf11669ccd753c22b172aa1cd2">linear</a> (const double dIn)</td></tr>
<tr class="separator:a96074fbf11669ccd753c22b172aa1cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468e26c0550542d30ccfa5f8b6cb46d7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#a468e26c0550542d30ccfa5f8b6cb46d7">gaussian</a> (const double dIn)</td></tr>
<tr class="separator:a468e26c0550542d30ccfa5f8b6cb46d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32d74114e82f68057cae5a4cf27668f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#af32d74114e82f68057cae5a4cf27668f">square</a> (const double dIn)</td></tr>
<tr class="separator:af32d74114e82f68057cae5a4cf27668f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc27fe6c502437863941a3260821ab14"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02344.html#abc27fe6c502437863941a3260821ab14">cubic</a> (const double dIn)</td></tr>
<tr class="separator:abc27fe6c502437863941a3260821ab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class holds methods for creating distance-based weight matrices and for interpolating signals. </p>
<p>Calculates and stores a matrix which provides the information how much each vertex is influenced by every sensor. On this basis, the user can use sensor data to calculate interpolated values for each sensor of the mesh. The user can choose the function that is used in the interpolation. Three functions are provided. <a class="el" href="a02344.html" title="This class holds methods for creating distance-based weight matrices and for interpolating signals.">Interpolation</a> weights are calculated using the following formula: <img src="./interpolation_formula.png" alt="weight matrix" class="inline"/> where w are interpolation weights, d are distances, m is the number of columsn and f is the used function. </p>

<p class="definition">Definition at line <a class="el" href="a00794_source.html#l00088">88</a> of file <a class="el" href="a00794_source.html">interpolation.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a065d5937d04e1d500da2e7366f7343e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065d5937d04e1d500da2e7366f7343e5">&#9670;&nbsp;</a></span>ConstSPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef QSharedPointer&lt;const <a class="el" href="a02344.html">Interpolation</a>&gt; <a class="el" href="a02344.html#a065d5937d04e1d500da2e7366f7343e5">DISP3DLIB::Interpolation::ConstSPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Const shared pointer type for <a class="el" href="a02344.html" title="This class holds methods for creating distance-based weight matrices and for interpolating signals.">Interpolation</a>. </p>

<p class="definition">Definition at line <a class="el" href="a00794_source.html#l00093">93</a> of file <a class="el" href="a00794_source.html">interpolation.h</a>.</p>

</div>
</div>
<a id="ae78200c5ac018b82d0c2ddd5e0987f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78200c5ac018b82d0c2ddd5e0987f42">&#9670;&nbsp;</a></span>SPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef QSharedPointer&lt;<a class="el" href="a02344.html">Interpolation</a>&gt; <a class="el" href="a02344.html#ae78200c5ac018b82d0c2ddd5e0987f42">DISP3DLIB::Interpolation::SPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shared pointer type for <a class="el" href="a02344.html" title="This class holds methods for creating distance-based weight matrices and for interpolating signals.">Interpolation</a>. </p>

<p class="definition">Definition at line <a class="el" href="a00794_source.html#l00092">92</a> of file <a class="el" href="a00794_source.html">interpolation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3bca8308a44135286a0bf9479dbeee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bca8308a44135286a0bf9479dbeee4">&#9670;&nbsp;</a></span>Interpolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DISP3DLIB::Interpolation::Interpolation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deleted default constructor (static class). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4311446f073b11ec8e644981a92aeef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4311446f073b11ec8e644981a92aeef3">&#9670;&nbsp;</a></span>createInterpolationMat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; SparseMatrix&lt; float &gt; &gt; Interpolation::createInterpolationMat </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecProjectedSensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QSharedPointer&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>matDistanceTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>interpolationFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dCancelDist</em> = <code>FLOAT_INFINITY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecExcludeIndex</em> = <code>QVector&lt;int&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method calculates the weight matrix that is later needed for the interpolation of signals. The matrix will have n rows, where n is the number of rows of the passed distance table (i.e. the number of vertices of the mesh that the table is based on), and m columns, where m is the number of mapped sensors on the mesh (based on a prior sensor-to-mesh mapping). <em>createInterplationMat</em> calculates the matrix according to the following scheme:</p><ol type="1">
<li>if the vertex belongs to a sensor: The value at the position of the sensor is 1 and all other values in this row are set to 0</li>
<li>if not: the values are calculated to give a total of 1 (a lot of values will stay 0, because they are too far away to influence) by using the above mentioned formula</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vecProjectedSensors</td><td>Vector of IDs of sensor vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matDistanceTable</td><td>Matrix that contains all needed distances. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolationFunction</td><td>Function that computes interpolation coefficients using the distance values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dCancelDist</td><td>Distances higher than this are ignored, i.e. the respective coefficients are set to zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vecExcludeIndex</td><td>The indices to be excluded from vecProjectedSensors, e.g., bad channels (empty by default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance matrix created. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00791_source.html#l00071">71</a> of file <a class="el" href="a00791_source.html">interpolation.cpp</a>.</p>

</div>
</div>
<a id="abc27fe6c502437863941a3260821ab14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc27fe6c502437863941a3260821ab14">&#9670;&nbsp;</a></span>cubic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Interpolation::cubic </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates interpolation weights based on distance values. Returns interpolation weight that corresponds to cubic hyperbel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dIn</td><td>Distance value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function value of the cubic hyperbel at d. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00791_source.html#l00191">191</a> of file <a class="el" href="a00791_source.html">interpolation.cpp</a>.</p>

</div>
</div>
<a id="a468e26c0550542d30ccfa5f8b6cb46d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468e26c0550542d30ccfa5f8b6cb46d7">&#9670;&nbsp;</a></span>gaussian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Interpolation::gaussian </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates interpolation weights based on distance values. Returns interpolation weight that corresponds to gauss curve with sigma set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dIn</td><td>Distance value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function value of the gauss curve at d. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00791_source.html#l00177">177</a> of file <a class="el" href="a00791_source.html">interpolation.cpp</a>.</p>

</div>
</div>
<a id="a3607f1bfdf7eeb7c3a11027abadf05ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3607f1bfdf7eeb7c3a11027abadf05ba">&#9670;&nbsp;</a></span>interpolateSignal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::VectorXf DISP3DLIB::Interpolation::interpolateSignal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>matInterpolationMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>vecMeasurementData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The interpolation essentially corresponds to a matrix * vector multiplication. A vector of sensor data (i.e. a vector of double-values) is multiplied with the result of the <em>createInterpolationMat</em>. The result is a vector that contains interpolated values for all vertices of the mesh that was used to create the weight matrix, i.e. in first instance the distance table that the weight matrix is based on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matInterpolationMatrix</td><td>The weight matrix which should be used for multiplying. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vecMeasurementData</td><td>A vector with measured sensor data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated values for all vertices of the mesh. </dd></dl>

</div>
</div>
<a id="a54f29bfc9a18cfa3833486c6c4c487e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f29bfc9a18cfa3833486c6c4c487e8">&#9670;&nbsp;</a></span>interpolateSignal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::VectorXf DISP3DLIB::Interpolation::interpolateSignal </td>
          <td>(</td>
          <td class="paramtype">const QSharedPointer&lt; Eigen::SparseMatrix&lt; float &gt; &gt;&#160;</td>
          <td class="paramname"><em>matInterpolationMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QSharedPointer&lt; Eigen::VectorXf &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecMeasurementData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The interpolation essentially corresponds to a matrix * vector multiplication. A vector of sensor data (i.e. a vector of double-values) is multiplied with the result of the <em>createInterpolationMat</em>. The result is a vector that contains interpolated values for all vertices of the mesh that was used to create the weight matrix, i.e. in first instance the distance table that the weight matrix is based on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matInterpolationMatrix</td><td>The weight matrix which should be used for multiplying. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vecMeasurementData</td><td>A vector with measured sensor data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated values for all vertices of the mesh. </dd></dl>

</div>
</div>
<a id="a96074fbf11669ccd753c22b172aa1cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96074fbf11669ccd753c22b172aa1cd2">&#9670;&nbsp;</a></span>linear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Interpolation::linear </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serves as a placeholder for other functions and is needed in case a linear interpolation is wanted when calling <em>createInterplationMat</em>.Returns input argument unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dIn</td><td>Distance value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same value interpreted as a interpolation weight. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00791_source.html#l00170">170</a> of file <a class="el" href="a00791_source.html">interpolation.cpp</a>.</p>

</div>
</div>
<a id="af32d74114e82f68057cae5a4cf27668f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32d74114e82f68057cae5a4cf27668f">&#9670;&nbsp;</a></span>square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Interpolation::square </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates interpolation weights based on distance values. Returns interpolation weight that corresponds to negative parabel with an y-offset of 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dIn</td><td>Distance value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function value of the negative parabel at d. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00791_source.html#l00184">184</a> of file <a class="el" href="a00791_source.html">interpolation.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/libraries/disp3D/helpers/interpolation/<a class="el" href="a00794_source.html">interpolation.h</a></li>
<li>src/libraries/disp3D/helpers/interpolation/<a class="el" href="a00791_source.html">interpolation.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 9 2023 17:55:44 for MNE-CPP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
