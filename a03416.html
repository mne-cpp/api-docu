<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MNE-CPP: UTILSLIB::MNEMath Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MNE-CPP_Doxygen_Logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MNE-CPP
   &#160;<span id="projectnumber">0.1.9</span>
   </div>
   <div id="projectbrief">A Framework for Electrophysiology</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>UTILSLIB</b></li><li class="navelem"><a class="el" href="a03416.html">MNEMath</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="a03413.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UTILSLIB::MNEMath Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Math methods.  
 <a href="a03416.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a01715_source.html">mnemath.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3129ad163aae01f8855c1d5ae163e782"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a3129ad163aae01f8855c1d5ae163e782">IdxIntValue</a></td></tr>
<tr class="separator:a3129ad163aae01f8855c1d5ae163e782"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a52c52d62e3393a51837e7a12688d1439"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a52c52d62e3393a51837e7a12688d1439">~MNEMath</a> ()</td></tr>
<tr class="separator:a52c52d62e3393a51837e7a12688d1439"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6fa257a5b36333ac44f12f69b6a076bb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a6fa257a5b36333ac44f12f69b6a076bb">gcd</a> (int iA, int iB)</td></tr>
<tr class="separator:a6fa257a5b36333ac44f12f69b6a076bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77881739a5ebe98739015baaafa8b272"><td class="memItemLeft" align="right" valign="top">static Eigen::VectorXd *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a77881739a5ebe98739015baaafa8b272">combine_xyz</a> (const Eigen::VectorXd &amp;vec)</td></tr>
<tr class="separator:a77881739a5ebe98739015baaafa8b272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31541efeaa0984c03668dbcbe463a96"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#ad31541efeaa0984c03668dbcbe463a96">getConditionNumber</a> (const Eigen::MatrixXd &amp;A, Eigen::VectorXd &amp;s)</td></tr>
<tr class="separator:ad31541efeaa0984c03668dbcbe463a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400ac989223a9d2fd15dee9d52ba3c7f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a400ac989223a9d2fd15dee9d52ba3c7f">getConditionSlope</a> (const Eigen::MatrixXd &amp;A, Eigen::VectorXd &amp;s)</td></tr>
<tr class="separator:a400ac989223a9d2fd15dee9d52ba3c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e79a42668a3e43611147f0705613d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a27e79a42668a3e43611147f0705613d2">get_whitener</a> (Eigen::MatrixXd &amp;A, bool pca, QString ch_type, Eigen::VectorXd &amp;eig, Eigen::MatrixXd &amp;eigvec)</td></tr>
<tr class="separator:a27e79a42668a3e43611147f0705613d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542823d455036559d8098bc78b9353ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a542823d455036559d8098bc78b9353ba">get_whitener</a> (Eigen::MatrixXd &amp;A, bool pca, const std::string &amp;ch_type, Eigen::VectorXd &amp;eig, Eigen::MatrixXd &amp;eigvec)</td></tr>
<tr class="separator:a542823d455036559d8098bc78b9353ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c00bba4764cf2a2eeda9df19c02fba8"><td class="memItemLeft" align="right" valign="top">static Eigen::VectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a6c00bba4764cf2a2eeda9df19c02fba8">intersect</a> (const Eigen::VectorXi &amp;v1, const Eigen::VectorXi &amp;v2, Eigen::VectorXi &amp;idx_sel)</td></tr>
<tr class="separator:a6c00bba4764cf2a2eeda9df19c02fba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfda70b3adf710d1d1344700514f1675"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#acfda70b3adf710d1d1344700514f1675">issparse</a> (Eigen::VectorXd &amp;v)</td></tr>
<tr class="separator:acfda70b3adf710d1d1344700514f1675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014a77ce3bee7edc9b7afcf7604f46e1"><td class="memItemLeft" align="right" valign="top">static Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a014a77ce3bee7edc9b7afcf7604f46e1">legendre</a> (qint32 n, const Eigen::VectorXd &amp;X, QString normalize=QString(&quot;unnorm&quot;))</td></tr>
<tr class="separator:a014a77ce3bee7edc9b7afcf7604f46e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef840cfb3ae8cd8b07849d6609612eb"><td class="memItemLeft" align="right" valign="top">static Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a5ef840cfb3ae8cd8b07849d6609612eb">legendre</a> (qint32 n, const Eigen::VectorXd &amp;X, std::string normalize=&quot;unnorm&quot;)</td></tr>
<tr class="separator:a5ef840cfb3ae8cd8b07849d6609612eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c2c671b431d27e0ecdf32b48fd45c5"><td class="memItemLeft" align="right" valign="top">static Eigen::SparseMatrix&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a55c2c671b431d27e0ecdf32b48fd45c5">make_block_diag</a> (const Eigen::MatrixXd &amp;A, qint32 n)</td></tr>
<tr class="separator:a55c2c671b431d27e0ecdf32b48fd45c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a6acb8de351255626065bb69e7c69f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a78a6acb8de351255626065bb69e7c69f">nchoose2</a> (int n)</td></tr>
<tr class="separator:a78a6acb8de351255626065bb69e7c69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae851ce9b87f4db0b7d0e6626c34cf04f"><td class="memItemLeft" align="right" valign="top">static qint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#ae851ce9b87f4db0b7d0e6626c34cf04f">rank</a> (const Eigen::MatrixXd &amp;A, double tol=1e-8)</td></tr>
<tr class="separator:ae851ce9b87f4db0b7d0e6626c34cf04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebf8a8b752599fb1562205d297bdc96"><td class="memItemLeft" align="right" valign="top">static Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a2ebf8a8b752599fb1562205d297bdc96">rescale</a> (const Eigen::MatrixXd &amp;data, const Eigen::RowVectorXf &amp;times, const QPair&lt; float, float &gt; &amp;baseline, QString mode)</td></tr>
<tr class="separator:a2ebf8a8b752599fb1562205d297bdc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330e3b433481550678d0977d0fba5230"><td class="memItemLeft" align="right" valign="top">static Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a330e3b433481550678d0977d0fba5230">rescale</a> (const Eigen::MatrixXd &amp;data, const Eigen::RowVectorXf &amp;times, const std::pair&lt; float, float &gt; &amp;baseline, const std::string &amp;mode)</td></tr>
<tr class="separator:a330e3b433481550678d0977d0fba5230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e854d2824f59ffc8451a8d7bbd8930"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16e854d2824f59ffc8451a8d7bbd8930"><td class="memTemplItemLeft" align="right" valign="top">static Eigen::VectorXi&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#a16e854d2824f59ffc8451a8d7bbd8930">sort</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, bool desc=true)</td></tr>
<tr class="separator:a16e854d2824f59ffc8451a8d7bbd8930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148f10a2567d2ab9ffe3924deb1f9a51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a148f10a2567d2ab9ffe3924deb1f9a51"><td class="memTemplItemLeft" align="right" valign="top">static Eigen::VectorXi&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#a148f10a2567d2ab9ffe3924deb1f9a51">sort</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v_prime, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;mat, bool desc=true)</td></tr>
<tr class="separator:a148f10a2567d2ab9ffe3924deb1f9a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7a7a6239e2e00f70892dd88967527"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adda7a7a6239e2e00f70892dd88967527"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; Eigen::Triplet&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#adda7a7a6239e2e00f70892dd88967527">sortrows</a> (const std::vector&lt; Eigen::Triplet&lt; T &gt; &gt; &amp;A, qint32 column=0)</td></tr>
<tr class="separator:adda7a7a6239e2e00f70892dd88967527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574c6bdbdc3df1ef765b8e3db44dc80f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a574c6bdbdc3df1ef765b8e3db44dc80f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#a574c6bdbdc3df1ef765b8e3db44dc80f">compareIdxValuePairBiggerThan</a> (const std::pair&lt; int, T &gt; &amp;lhs, const std::pair&lt; int, T &gt; &amp;rhs)</td></tr>
<tr class="separator:a574c6bdbdc3df1ef765b8e3db44dc80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4b1c309b2d8cf04bc176d7883a3498"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec4b1c309b2d8cf04bc176d7883a3498"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#aec4b1c309b2d8cf04bc176d7883a3498">compareIdxValuePairSmallerThan</a> (const std::pair&lt; int, T &gt; &amp;lhs, const std::pair&lt; int, T &gt; &amp;rhs)</td></tr>
<tr class="separator:aec4b1c309b2d8cf04bc176d7883a3498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9a9eba2af43393b42b7bbec61adeeb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b9a9eba2af43393b42b7bbec61adeeb"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#a5b9a9eba2af43393b42b7bbec61adeeb">compareTripletFirstEntry</a> (const Eigen::Triplet&lt; T &gt; &amp;lhs, const Eigen::Triplet&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a5b9a9eba2af43393b42b7bbec61adeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331a9cb7403c49c7700acadf8496cdd0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a331a9cb7403c49c7700acadf8496cdd0"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#a331a9cb7403c49c7700acadf8496cdd0">compareTripletSecondEntry</a> (const Eigen::Triplet&lt; T &gt; &amp;lhs, const Eigen::Triplet&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a331a9cb7403c49c7700acadf8496cdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affffe64d961a9923bb9e6480edfed402"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:affffe64d961a9923bb9e6480edfed402"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#affffe64d961a9923bb9e6480edfed402">log2</a> (const T d)</td></tr>
<tr class="separator:affffe64d961a9923bb9e6480edfed402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37fca29c8170f27e3d4848fa5b27356"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac37fca29c8170f27e3d4848fa5b27356"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#ac37fca29c8170f27e3d4848fa5b27356">histcounts</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;matRawData, bool bMakeSymmetrical, int iClassAmount, Eigen::VectorXd &amp;vecResultClassLimits, Eigen::VectorXi &amp;vecResultFrequency, double dGlobalMin=0.0, double dGlobalMax=0.0)</td></tr>
<tr class="separator:ac37fca29c8170f27e3d4848fa5b27356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37833c9790fa808b8bc4c3e6b6307937"><td class="memTemplParams" colspan="2"><a id="a37833c9790fa808b8bc4c3e6b6307937"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37833c9790fa808b8bc4c3e6b6307937"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>histcounts</b> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;matRawData, bool bMakeSymmetrical, int iClassAmount, Eigen::VectorXd &amp;vecResultClassLimits, Eigen::VectorXi &amp;vecResultFrequency, double dGlobalMin=0.0, double dGlobalMax=0.0)</td></tr>
<tr class="separator:a37833c9790fa808b8bc4c3e6b6307937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1646aa5af794caa832aaaca991b349e7"><td class="memTemplParams" colspan="2"><a id="a1646aa5af794caa832aaaca991b349e7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1646aa5af794caa832aaaca991b349e7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>histcounts</b> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;matRawData, bool bMakeSymmetrical, int iClassAmount, Eigen::VectorXd &amp;vecResultClassLimits, Eigen::VectorXi &amp;vecResultFrequency, double dGlobalMin=0.0, double dGlobalMax=0.0)</td></tr>
<tr class="separator:a1646aa5af794caa832aaaca991b349e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ce5e9f262dcb025bc60ae217268b34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55ce5e9f262dcb025bc60ae217268b34"><td class="memTemplItemLeft" align="right" valign="top">static Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a03416.html#a55ce5e9f262dcb025bc60ae217268b34">pinv</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;a)</td></tr>
<tr class="separator:a55ce5e9f262dcb025bc60ae217268b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae96cf6506c14864b8ce5463dd3acea"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03416.html#a2ae96cf6506c14864b8ce5463dd3acea">compareTransformation</a> (const Eigen::MatrixX4f &amp;mDevHeadT, const Eigen::MatrixX4f &amp;mDevHeadTNew, const float &amp;fThreshRot, const float &amp;fThreshTrans)</td></tr>
<tr class="separator:a2ae96cf6506c14864b8ce5463dd3acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Math methods. </p>
<p>ToDo make this a template class Generalized math methods used by mne methods </p>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00087">87</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3129ad163aae01f8855c1d5ae163e782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3129ad163aae01f8855c1d5ae163e782">&#9670;&nbsp;</a></span>IdxIntValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;int,int&gt; <a class="el" href="a03416.html#a3129ad163aae01f8855c1d5ae163e782">UTILSLIB::MNEMath::IdxIntValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef of a pair of ints. </p>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00090">90</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a52c52d62e3393a51837e7a12688d1439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c52d62e3393a51837e7a12688d1439">&#9670;&nbsp;</a></span>~MNEMath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual UTILSLIB::MNEMath::~MNEMath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys the <a class="el" href="a03416.html" title="Math methods.">MNEMath</a> object </p>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00096">96</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77881739a5ebe98739015baaafa8b272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77881739a5ebe98739015baaafa8b272">&#9670;&nbsp;</a></span>combine_xyz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd * MNEMath::combine_xyz </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ToDo make this a template function</p>
<p>mne_combine_xyz</p>
<h3><a class="anchor" id="autotoc_md129"></a>
MNE toolbox root function</h3>
<p>Compute the three Cartesian components of a vector together</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>Input row vector [ x1 y1 z1 ... x_n y_n z_n ].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output vector [x1^2+y1^2+z1^2 ... x_n^2+y_n^2+z_n^2 ]. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00081">81</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="a574c6bdbdc3df1ef765b8e3db44dc80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574c6bdbdc3df1ef765b8e3db44dc80f">&#9670;&nbsp;</a></span>compareIdxValuePairBiggerThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UTILSLIB::MNEMath::compareIdxValuePairBiggerThan </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; int, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two index-value-pairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left hand side of the comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right hand side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value of lhs is bigger than value of rhs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00571">571</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<a id="aec4b1c309b2d8cf04bc176d7883a3498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4b1c309b2d8cf04bc176d7883a3498">&#9670;&nbsp;</a></span>compareIdxValuePairSmallerThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UTILSLIB::MNEMath::compareIdxValuePairSmallerThan </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; int, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two index-value-pairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left hand side of the comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right hand side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value of lhs is smaller than value of rhs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00580">580</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<a id="a2ae96cf6506c14864b8ce5463dd3acea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae96cf6506c14864b8ce5463dd3acea">&#9670;&nbsp;</a></span>compareTransformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNEMath::compareTransformation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixX4f &amp;&#160;</td>
          <td class="paramname"><em>mDevHeadT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixX4f &amp;&#160;</td>
          <td class="paramname"><em>mDevHeadTNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>fThreshRot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>fThreshTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare new head position with current head position and update dev_head_t if big displacement occured</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mDevHeadTrans</td><td>The device to head transformation matrix to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mDevHeadTransNew</td><td>The device to head transformation matrix to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fTreshRot</td><td>The threshold for big head rotation in degree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fThreshTrans</td><td>The threshold for big head movement in m.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bState The status that shows if devHead is updated or not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00571">571</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="a5b9a9eba2af43393b42b7bbec61adeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9a9eba2af43393b42b7bbec61adeeb">&#9670;&nbsp;</a></span>compareTripletFirstEntry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UTILSLIB::MNEMath::compareTripletFirstEntry </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Triplet&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Triplet&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares triplet first entry</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left hand side of the comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right hand side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value of lhs is smaller than value of rhs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00589">589</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<a id="a331a9cb7403c49c7700acadf8496cdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331a9cb7403c49c7700acadf8496cdd0">&#9670;&nbsp;</a></span>compareTripletSecondEntry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UTILSLIB::MNEMath::compareTripletSecondEntry </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Triplet&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Triplet&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares triplet second entry</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left hand side of the comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right hand side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value of lhs is smaller than value of rhs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00598">598</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<a id="a6fa257a5b36333ac44f12f69b6a076bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa257a5b36333ac44f12f69b6a076bb">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MNEMath::gcd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the Greatest Common Divisor (GCD) of two integer values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First input integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second input integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Greatest Common Divisor (GCD) of a and b. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00070">70</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="a542823d455036559d8098bc78b9353ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542823d455036559d8098bc78b9353ba">&#9670;&nbsp;</a></span>get_whitener() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTILSLIB::MNEMath::get_whitener </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ch_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>eig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>eigvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the whitener of a given matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Matrix to compute the whitener from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pca</td><td>perform a pca.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rank of matrix A. </dd></dl>

</div>
</div>
<a id="a27e79a42668a3e43611147f0705613d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e79a42668a3e43611147f0705613d2">&#9670;&nbsp;</a></span>get_whitener() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTILSLIB::MNEMath::get_whitener </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>ch_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>eig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>eigvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the whitener of a given matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Matrix to compute the whitener from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pca</td><td>perform a pca.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rank of matrix A. </dd></dl>

</div>
</div>
<a id="ad31541efeaa0984c03668dbcbe463a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31541efeaa0984c03668dbcbe463a96">&#9670;&nbsp;</a></span>getConditionNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MNEMath::getConditionNumber </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the condition number of a given matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Matrix to compute the condition number from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the condition number. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00104">104</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="a400ac989223a9d2fd15dee9d52ba3c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400ac989223a9d2fd15dee9d52ba3c7f">&#9670;&nbsp;</a></span>getConditionSlope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MNEMath::getConditionSlope </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the condition slope of a given matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Matrix to compute the condition number from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the condition slope. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00117">117</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="ac37fca29c8170f27e3d4848fa5b27356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37fca29c8170f27e3d4848fa5b27356">&#9670;&nbsp;</a></span>histcounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UTILSLIB::MNEMath::histcounts </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>matRawData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMakeSymmetrical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iClassAmount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vecResultClassLimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>vecResultFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dGlobalMin</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dGlobalMax</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>creates a class and frequency distribution from data matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matRawData</td><td>raw data matrix that needs to be analyzed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bMakeSymmetrical</td><td>user input to turn the x-axis symmetric. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iClassCount</td><td>user input to determine the amount of classes in the histogram. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vecResultClassLimits</td><td>the upper limit of each individual class. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vecResultFrequency</td><td>the amount of data that fits in the appropriate class ranges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dGlobalMin</td><td>user input to determine the maximum value allowed in the histogram. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dGlobalMax</td><td>user input to determine the minimum value allowed in the histogram. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00647">647</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<a id="a6c00bba4764cf2a2eeda9df19c02fba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c00bba4764cf2a2eeda9df19c02fba8">&#9670;&nbsp;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorXi MNEMath::intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>idx_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the intersection of two vectors</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Input vector 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Input vector 2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">idx_sel</td><td>Index of intersection based on v1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sorted, unique values that are in both of the input arrays. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00194">194</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="acfda70b3adf710d1d1344700514f1675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfda70b3adf710d1d1344700514f1675">&#9670;&nbsp;</a></span>issparse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNEMath::issparse </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if a given data (stored as vector v) are representing a sparse matrix. ToDo: status is experimental -&gt; needs to be increased in speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>data to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if sparse false otherwise;. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00288">288</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="a014a77ce3bee7edc9b7afcf7604f46e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014a77ce3bee7edc9b7afcf7604f46e1">&#9670;&nbsp;</a></span>legendre() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::MatrixXd UTILSLIB::MNEMath::legendre </td>
          <td>(</td>
          <td class="paramtype">qint32&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>QString(&quot;unnorm&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LEGENDRE Associated Legendre function.</p>
<p>P = LEGENDRE(N,X) computes the associated Legendre functions of degree N and order M = 0, 1, ..., N, evaluated for each element of X. N must be a scalar integer and X must contain real values between -1 &lt;= X &lt;= 1.</p>
<dl class="section return"><dt>Returns</dt><dd>associated Legendre functions. </dd></dl>

</div>
</div>
<a id="a5ef840cfb3ae8cd8b07849d6609612eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef840cfb3ae8cd8b07849d6609612eb">&#9670;&nbsp;</a></span>legendre() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::MatrixXd UTILSLIB::MNEMath::legendre </td>
          <td>(</td>
          <td class="paramtype">qint32&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>&quot;unnorm&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LEGENDRE Associated Legendre function.</p>
<p>P = LEGENDRE(N,X) computes the associated Legendre functions of degree N and order M = 0, 1, ..., N, evaluated for each element of X. N must be a scalar integer and X must contain real values between -1 &lt;= X &lt;= 1.</p>
<dl class="section return"><dt>Returns</dt><dd>associated Legendre functions. </dd></dl>

</div>
</div>
<a id="affffe64d961a9923bb9e6480edfed402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affffe64d961a9923bb9e6480edfed402">&#9670;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double UTILSLIB::MNEMath::log2 </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute log2 of given number</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>input value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double result of log2 operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00607">607</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<a id="a55c2c671b431d27e0ecdf32b48fd45c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c2c671b431d27e0ecdf32b48fd45c5">&#9670;&nbsp;</a></span>make_block_diag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparseMatrix&lt; double &gt; * MNEMath::make_block_diag </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qint32&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ToDo make this a template function</p>
<h3><a class="anchor" id="autotoc_md130"></a>
MNE toolbox root function ###: Definition of the mne_block_diag function - encoding part</h3>
<p>Make a sparse block diagonal matrix</p>
<p>Returns a sparse block diagonal, diagonalized from the elements in "A". "A" is ma x na, comprising bdn=(na/"n") blocks of submatrices. Each submatrix is ma x "n", and these submatrices are placed down the diagonal of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Matrix which should be diagonlized. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n</td><td>Columns of the submatrices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sparse block diagonal, diagonalized from the elements in "A". </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00347">347</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="a78a6acb8de351255626065bb69e7c69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a6acb8de351255626065bb69e7c69f">&#9670;&nbsp;</a></span>nchoose2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MNEMath::nchoose2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the combination of n over 2 (nchoosek(n,2))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements which should be combined with each other (n over 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of combinations. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00387">387</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="a55ce5e9f262dcb025bc60ae217268b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ce5e9f262dcb025bc60ae217268b34">&#9670;&nbsp;</a></span>pinv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; UTILSLIB::MNEMath::pinv </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates the pseudo inverse of a matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>raw data matrix that needs to be analyzed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00755">755</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<a id="ae851ce9b87f4db0b7d0e6626c34cf04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae851ce9b87f4db0b7d0e6626c34cf04f">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">qint32 MNEMath::rank </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ToDo make this a template function</p>
<p>Returns the rank of a matrix A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Matrix to get the rank from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>realtive threshold: biggest singualr value multiplied with tol is smallest singular value considered non-zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rank of matrix A. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01712_source.html#l00399">399</a> of file <a class="el" href="a01712_source.html">mnemath.cpp</a>.</p>

</div>
</div>
<a id="a2ebf8a8b752599fb1562205d297bdc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebf8a8b752599fb1562205d297bdc96">&#9670;&nbsp;</a></span>rescale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::MatrixXd UTILSLIB::MNEMath::rescale </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVectorXf &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QPair&lt; float, float &gt; &amp;&#160;</td>
          <td class="paramname"><em>baseline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ToDo: Maybe new processing class</p>
<p>Rescale aka baseline correct data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data Matrix (m x n_time). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>Time instants is seconds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseline</td><td>If baseline is (a, b) the interval is between "a (s)" and "b (s)". If a and b are equal use interval between the beginning of the data and the time point 0 (stimulus onset). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Do baseline correction with ratio (power is divided by mean power during baseline) or zscore (power is divided by standard. deviatio of power during baseline after substracting the mean, power = [power - mean(power_baseline)] / std(power_baseline)). ("logratio" | "ratio" | "zscore" | "mean" | "percent")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rescaled data matrix rescaling. </dd></dl>

</div>
</div>
<a id="a330e3b433481550678d0977d0fba5230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330e3b433481550678d0977d0fba5230">&#9670;&nbsp;</a></span>rescale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::MatrixXd UTILSLIB::MNEMath::rescale </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVectorXf &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; float, float &gt; &amp;&#160;</td>
          <td class="paramname"><em>baseline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ToDo: Maybe new processing class</p>
<p>Rescale aka baseline correct data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data Matrix (m x n_time). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>Time instants is seconds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseline</td><td>If baseline is (a, b) the interval is between "a (s)" and "b (s)". If a and b are equal use interval between the beginning of the data and the time point 0 (stimulus onset). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Do baseline correction with ratio (power is divided by mean power during baseline) or zscore (power is divided by standard. deviatio of power during baseline after substracting the mean, power = [power - mean(power_baseline)] / std(power_baseline)). ("logratio" | "ratio" | "zscore" | "mean" | "percent")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rescaled data matrix rescaling. </dd></dl>

</div>
</div>
<a id="a16e854d2824f59ffc8451a8d7bbd8930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e854d2824f59ffc8451a8d7bbd8930">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi UTILSLIB::MNEMath::sort </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desc</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts a vector (ascending order) in place and returns the track of the original indeces</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>vector to sort; it's sorted in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>if true its sorted in a descending order, otherwise ascending (optional, default = true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of the original indeces in the new order. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00499">499</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<a id="a148f10a2567d2ab9ffe3924deb1f9a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148f10a2567d2ab9ffe3924deb1f9a51">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi UTILSLIB::MNEMath::sort </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_prime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desc</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts a vector (ascending order) and a corresponding matrix in place and returns the track of the original indeces The matrix is sorted along the columns using the vector values for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v_prime</td><td>vector to sort (sorted in place). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mat</td><td>matrix to sort (sorted in place). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>if true its sorted in a descending order, otherwise ascending (optional, default = true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of the original indeces in the new order. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00531">531</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<a id="adda7a7a6239e2e00f70892dd88967527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda7a7a6239e2e00f70892dd88967527">&#9670;&nbsp;</a></span>sortrows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Triplet&lt; T &gt; &gt; UTILSLIB::MNEMath::sortrows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Triplet&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qint32&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sort rows in ascending order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>triplet vector to sort (sorted in place). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>sorts the triplet vector based on the column specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of the original indeces in the new order. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a01715_source.html#l00552">552</a> of file <a class="el" href="a01715_source.html">mnemath.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/libraries/utils/<a class="el" href="a01715_source.html">mnemath.h</a></li>
<li>src/libraries/utils/<a class="el" href="a01712_source.html">mnemath.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 9 2023 17:55:45 for MNE-CPP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
